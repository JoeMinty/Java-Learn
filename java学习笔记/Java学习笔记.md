## 一、Java的基本程序设计结构

### 1、一个简单的Java应用程序

1. Java中定义类名的规则很宽松。名字必须以字母开头，后面可以跟字母和数字的任意组合。长度基本没有限制。但是不能使用Java保留字(例如，public或class);

   标准的命名规范为(类名FirstSample就遵循了这个规范)：类名是以大写字母开头的名词。 

2. Java虚拟机将从指定类中的main方法开始执行(这里的“方法”就是Java中所说的“函数”）。

3. 根据Java语言规范，main方法必须声明为public。

4. Java中任何方法的代码都用“｛｝”开始，结束。

5. System.out是一个对象，常用的调用方法是println和print,print方法它在输出之后不换行。

6. 、Java与C/C++一样，都采用双引号分隔字符串。

   ​

### 2、数据类型

1. Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。

2. 长整型数值有一个后缀L或l(如400000000L)。十六进制数值有一个前缀0x或0X(如0xCAFE)。八进制有一个前缀0，例如，010对应八进制中的8。

3. 加上前缀0b或0B就可以写二进制数。例如，0b1001就是9。

4. double表示这种类型的数值精度是float类型的两倍（有人称之为双精度数值）。

5. float类型的数值有一个后缀F或f(例如，3.14F)。没有后缀F的浮点数值（如3.14）默认为double类型。当然，也可以在浮点数值后面添加后缀D或d(例如，3.14D)。

6. ASCII是美国的字节码；

7. boolean(布尔)类型有两个值：false和true，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换。


###3、变量

1. $是一个合法的Java字符，但是不要在代码中使用这个字符，它只用在Java编译器或其他工具生成的名字中。

2. 声明一个变量之后，必须使用赋值语句对变量进行显示初始化；

3. 在Java中，利用关键字final指示常量；关键字final表示这个变量只能被赋值一次。一旦被赋值之后，就不能够更改了。习惯上，常量名使用全大写。

4. Java中，整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或NaN结果；

5. &&和||运算符是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。

   示例： `x!=0 && 1/x > x+y //no division b`

6. Java支持三元操作符？：，这种操作符有时很有用。如果条件为true,下面的表达式：

    `condition ? expression1 : expression2`

   就为第一个表达式的值，否则计算为第二个表达式的值。

7. 应用在布尔值上时，&和|运算符也会得到一个布尔值。这些运算符与&&和||运算符很类似，不过&和|运算符不采用“短路”方式来求值。

### 4、字符串

1. 任何一个Java对象都可以转换成字符串；
2. Java文档中将String类对象称为不可变字符串；
3. 不可变字符串有一个优点：编译器可以让字符串共享!
4. 不要使用==运算符检测两个字符串是否相等！这个运算符值能够确定两个字符串是否放置在同一个位置上。
5. 空串是一个Java对象，有自己的串长度（0）和内容（空）；
6. 在一个null值上调用方法，会出现错误；
7. CharSequence类型的参数，这是一种接口类型，所有字符串都属于这个接口。目前为止只要看到一个CharSequence形参，完全可以传入String类型的实参。

### 5、控制流程

1. 可以使用下面的调用方式找到路径的位置：

   `String dir=System.getProperty("user.dir")`

2. 块（即复合语句）是指由一对大括号括起来的若干条简单的Java语句。块确定了变量的作用域。一个块可以嵌套在另一个块中。但是不能在嵌套的两个块中声明同名的变量。

3. 当在for语句的第一部分中声明了一个变量之后，这个变量的作用域就为for循环的整个循环体；

4. 如果在for语句内部定义一个变量，这个变量就不能在循环体之外使用。因此，如果希望在for循环体之外使用循环计数器的最终值，就要确保这个变量在循环语句的前面且在外部声明；

   另一个方面，可以在各自独立的不同for循环中定义同名的变量；

5. Java还提供了一种带标签的break语句，用于跳出多重嵌套的循环语句。有时候，在嵌套很深的循环语句中会发生一些不可预料的事情。此时可能更加希望跳到嵌套的所有循环语句之外。通过添加一些额外的条件判断实现各层循环的检测很不方便。

   下面一个示例说明了break语句的工作状态。注意：标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号。

   `Scanner in = new Scanner(System.in);`

   `int n;`

   `read_data`:

   `while(...){`

   ​	....

   ​	`for`(...)

   ​	`System.out.print("Enter a number>=0:");`

   ​	`n=in.nextInt();`

   ​	`if(n<0)`

   ​		`break read_data`

   `}`

`}`

​		事实上，可以将标签应用到任何语句中，甚至可以应用到if语句或者块语句中。

6. 如果将continue语句用于for循环中，就可以跳到for循环的“更新”部分。

### 6、数组

1. 数组长度不要求是常量：new int[n]会创建一个长度为n的数组；
2. 创建一个数字数组时，所有元素都初始化为0。boolean数组的元素会初始化为false。对象数组的元素则初始化为一个特殊值null，这表示这些元素（还）未存放任何对象；
3. 一旦创建了数组，就不能再改变它的大小（尽管可以改变每一个数组元素）；
4. 在Java，允许将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组；

## 二、对象与类

### 1、面向对象程序设计概述

1. 在Java中，所有的类都源自于一个“神通广大的超类”，它就是Object;

### 2、自定义类

1. 构造器的名字应该与类名相同。因此Date类的构造器名为Date;

2. 在一个源文件中，只能有一个公有类，但可以有任意数目的非公有类；

3. 关键字public意味着任何类的任何方法都可以调用这些方法；

4. 关键字private确保只要Employee类自身的方法能够访问这些实例域，而其他类的方法不能读写这些域；

5. 构造器与类同名。在构造Employee类的对象时，构造器会运行，以便将实力域初始化为所希望的状态；

6. 构造器与其他的方法有一个重要的不同，构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实力域的目的；

7. 构造的特点：

   > 构造器与类同名
   >
   > 每个类可以有一个以上的构造器
   >
   > 构造器可以有0个、1个或多个参数
   >
   > 构造器没有返回值
   >
   > 构造器总是伴随着new操作一起调用



8. 在一个方法中，关键字this表示隐式参数；

9. 在有些时候，需要获得或设置实例域的值：

   > 一个私有的数据域；
   >
   > 一个公有的域访问器方法；
   >
   > 一个公有的域更改器方法；

10. 更改器方法可以执行错误检查，然而直接对域进行赋值将不会进行这些处理；

11. 如果需要返回一个可变数据域的拷贝，就应该使用clone;

12. 在实现一个类时，由于公有数据非常危险，所以应该将所有的数据域都设置为私有的。

13. 可以将实力域定义为final。构建对象时必须初始化这样的域。也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。

14. final修饰符大都应用于基本（primitive）类型域，或不可变（immutable）类的域（如果类中的每个方法都不会改变其对象，这种类就是不可变的类。例如，String类就是一个不可变的类）。

### 3、静态域与静态方法

1. 可以认为静态方法是没有this参数的方法（在一个非静态的方法中，this参数表示这个方法的隐式参数）；

2. 可以使用对象调用静态方法。例如，如果harry是一个Employee对象，可以用harry.getNextId()代替Employee.getNextId()。不过，这种方式很容易造成混淆，其原因是getNextId方法计算的结果与harry毫无关系。我们建议使用类名，而不是对象来调用静态方法；

3. 在下面两种情况下使用静态方法：

   >一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow);
   >
   >一个方法只需要访问类的静态域（例如：Employee.getNextId）。

### 4、方法参数

1. **按值引用(call by value)**表示方法接收的是调用者提供的值。而按**引用调用（call by reference)**表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。

2. Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。

3. 一个方法不可能修改一个基本数据类型的参数。而对象引用作为参数就不同了。

4. 方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。

5. Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。

   下面总结一下Java中方法参数的使用情况：

   >一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）
   >
   >一个方法可以改变一个对象参数的状态；
   >
   >一个方法不能让对象参数引用一个新的对象。

### 5、对象构造

1. 如果多个方法（比如，StringBuilder构造器方法）有相同的名字、不同的参数，便产生了**重载**。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数，就会产生编译时错误，因为根本不存在匹配，或者没有一个比其他的更好。（这个过程被称为**重载解析（overloading resolution）.**）

2. Java允许重载任何方法，而不只是构造器方法。因此，要完整地描述一个方法，需要指出方法名以及参数类型。这叫做**方法的签名（signature）**。例如，String类有四个称为indexOf的公有方法。它们的签名是：

   >indexOf(int)
   >
   >indexOf(int,int)
   >
   >indexOf(String)
   >
   >indexOf(String,int)

   返回类型不是方法签名的一部分。也就是说，不能有两个名字相同、参数类型也相同却返回不同类型值的方法。

3. 如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值：数值为0、布尔值为false、对象引用为null。

4. 这是域与局部变量的主要不同点。必须明确地初始化方法中的局部变量，但是，如果没哟初始化类中的域，将会被自动初始化为默认值（0、false或null）。

5. 如果在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。于是，实例域中的数值型数据设置为0、布尔型数据设置为false、所有对象变量将设置为null。

6. 如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时没有提供参数就会被视为不合法。

7. 仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器。

8. 如果一个构造器的第一个语句形如this(...),这个构造器将调用同一个类的另一个构造器。

9. Java中三种初始化数据域的方法：

   >在构造器中设置值
   >
   >在声明中赋值
   >
   >**初始化块**，在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。

10. 由于Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。

### 6、包

1. 从编译器的角度来看，嵌套的包之间没有任何关系。例如，java.util包与java.util.jar包毫无关系。每一个都拥有独立的类集合。
2. 一个类可以使用所属包中的所有类，以及其他包中的公有类（public calss）；
3. 可以使用import语句导入一个特定的类或者整个包。import语句应该位于源文件的顶部（但位于package语句的后面）；
4. 只能使用星号(*)导入一个包，而不能使用import java..\*或import java.\*.\*导入以java为前缀的所有包；
5. import语句不仅可以导入类，还增加了导入静态方法和静态域的功能；
6. 如果没有在源文件中放置package语句，这个源文件中的类就被放置在一个默认包（default package）中。默认包是一个没有名字的包；
7. 标记为public的部分可以被任意的类使用；标记为private的部分只能被定义它们的类使用。如果没有指定public或private,这个部分（类、方法或变量）可以被同一个包中的所有方法访问；
8. 类存储在文件系统的子目录中。类的路径必须与包名匹配。

### 7、总结

1. 类注释必须放在import语句之后，类定义之前。

2. 每一个方法注释必须放在所描述的方法之前。除了通用标记之外；

3. 如果类是不可变的，就可以安全地在多个线程间共享其对象；

4. 类设计技巧：

   >1.一定要保证数据私有
   >
   >2.一定要对数据初始化
   >
   >3.不要在类中使用过多的基本类型
   >
   >4.不是所有的域都需要独立的域访问器和域更改器
   >
   >5.将职责过多的类进行分解
   >
   >6.类名和方法名要能够体现它们的职责
   >
   >7.优先使用不可变的类

## 三、继承

### 1、类、超类和子类

1. 利用**继承**，人们可以基于已存在的类构造一个新类，继承已存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。

2. **反射**是指程序在运行期间发现更多的类及其属性的能力；

3. 关键字extends表示继承；

4. 关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为超类（superclass）、基类（base class）或父类（parent class）;新类称为子类(subclass)、派生类（derived class）或孩子类(child class)。

5. 子类比超类拥有的功能更加丰富。

6. 在通过扩展超类定义子类的时候，仅需要支出子类与超类的不同之处。因此在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。

7. 使用super调用构造器的语句必须是子类构造器的第一条语句；

8. 如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器；

9. 关键字**this**有两个用途：

   * 引用隐式参数
   * 调用该类其他的构造器

   **super**关键字也有两个用途：

   * 调用超类的方法
   * 调用超类的构造器

   在调用构造器的时候，这两个关键字的使用方式很相似。调用构造器的语句只能作为另一个构造器的第一条语句出现。构造参数既可以传递给本类(this)的其他构造器，也可以传递给超类(super)的构造器。

10. 一个对象变量可以指示多种实际类型的现象被称为**多态（polymorphism）**。在运行是能够自动地选择调用哪个方法的现象称为**动态绑定(dynamic binding)**

11. 由一个公共超类派生出来的所有类的集合被称为**继承层次（inheritance hierarchy）**;在继承层次中，从某个特定的类到其祖先的路径被称为该类的**继承链（inheritance chain）**

12. Java不支持多继承

13. 可以将一个子类的对象赋给超类变量；但是不能将一个超类的引用赋值给子类变量；

14. 在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是public，子类方法一定要声明为public。经常会发生这类错误：在声明子类方法的时候，遗漏了public修饰符。此时，编译器将会把它解释为试图提供更严格的访问权限。

15. 有时候，可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为final类。

16. 类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法（final 类中的所有的方法自动地成为final方法）。

17. 域也可以被声明为final。对于final域来说，构造对象之后就不允许改变它们的值了。不过，如果将一个类声明为final,只有其中的方法自动地成为final,而不包括域。

18. 将方法或类声明为final主要目的是：确保它们不会在子类中改变语义。

19. String类也是final类，这意味着不允许任何人定义String的子类。换言之，如果有一个String的引用，它引用的一定是一个String对象，而不可能是其他类的对象。

20. 将一个类型强制转换成另外一个类型的过程被称为**类型转换**；

21. 进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能；

22. 将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检查。

23. 综上所述：

    * 只能在继承层次内进行类型转换
    * 在将超类转换成子类之前，应该使用instanceof进行检查

24. 为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的；

25. 除了抽象方法之外，抽象类还可以包含具体数据和具体方法；

26. 抽象方法充当着占位的角色，它们的具体实现在子类中。扩展抽象类可以有两种选择：

    * 一种是在抽象类中定义部分抽象方法或不定义抽象类方法，这样就必须将子类标记为抽象类；
    * 另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。

27. 类即使不含抽象方法，也可以将类声明为抽象类；

28. 抽象类不能被实例化。也就是说，如果将一个类声明abstract，就不能创建这个类的抽象；

    但是可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。

29. 最好将类中的域标记为private，而方法标记为public。任何声明为private的内容对其他类都是不可见的。这对于子类来说也完全适用，即子类也不能访问超类的私有域。

30. Java用于控制可见性的4个访问修饰符：

    * 仅对本类可见——private
    * 对所有类可见——public
    * 对本包和所有子类可见——protected
    * 对本包可见——默认（很遗憾），不需要修饰符。

### 2、Object：所有类的超类

1. Object类是Java中所有类的始祖，在Java中每个类都是由它扩展而来的；

2. 如果没有明确地指出超类，Object就被认为是这个类的超类。

3. 在Java中，只有基本类型(primitive types)不是对象，例如，数值、字符和布尔类型的值都不是对象。

4. 所有的数组类型中，不管是对象数组还是基本类型的数组都扩展了Object类。

5. Object类中的equals方法用于检测一个对象是否等于另外一个对象。在Object类中，这个方法将判断两个对象是否具有相同的引用。如果两个对象具有相同的引用，它们一定是相等的。

6. getClass方法将返回一个对象所属的类。

7. 对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等。

8. 可以使用@Override对覆盖超类的方法进行标记。

9. **散列码(hash code)**是由对象导出的一个整型值。散列码是没有规律的。

10. 由于hashCode方法定义在Object类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。

11. hashCode方法应该返回一个整型数值(也可以是负数)，并合理地组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀。

12. 在Object中还有一个重要的方法，就是toString方法，它用于返回表示对象值的字符串；

13. 随处可见toString方法的主要原因是：只要对象与一个字符串通过操作符“+”连接起来，Java编译就会自动地调用toString方法，以便获得这个对象的字符串描述。

14. ArrayList的类。它使用起来有点像数组，但在添加或删除元素时，具有自动调节数组容量的功能，而不需要为此编写任何代码。

15. ArrayList是一个采用类型参数(type parameter)的泛型类（generic class）。

16. 数组列表的容量与数组的大小有一个非常重要的区别。如果为数组分配100个元素的存储空间，数组就有100个空位置可用。而容量为100个元素的数组列表只是拥有保存100个元素的潜力（实际上，重新分配空间的话，将会超过100），但是在最初，甚至完成初始化构造之后，数组列表根本就不含有任何元素。

17. 对数组实施插入和删除元素的操作其效率比较低。对于小型数组来说，这一点不必担心。但如果数组存储的元素数比较多，又经常需要在中间位置插入、删除元素，就应该考虑使用**链表**了。

18. 有时，需要将int这样的基本类型转换为对象。所有的基本类型都有一个与之对应的类。例如，Integer类对应基本类型int。通常，这些类称为**包装器(wrapper)**。这些对象包装器类拥有很明显的名字：Integer、Long、Float、Double、Short、Byte、Character、Void和Boolean（前6个类派生于公共的超类Number）。对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。同时，对象包装器类还是final,因此不能定义它们的子类。

19. 当添加int类型的元素到ArrayList\<Integer>中。下面这个调用：

    ​	`list.add(3)`

    将自动地变换成

    ​	`list.add(Integer.valueOf(3))`

    这种变换被称为**自动装箱（autoboxing）**

20. 当将一个Integer对象赋给一个int值时，将会自动地**拆箱**；

21. ==运算符也可以应用于对象包装器对象，只不过监测的是对象是否指向同一个存储区域。

22. 自动装箱规范要求boolean、buye、char小于等于127，介于-128~127之间的short和int被包装到固定的对象中。

23. 由于包装器类引用可以为null，所以自动装箱有可能会抛出一个NullPointException异常。

24. 如果在一个条件表达式中混合使用Integer和Double类型，Integer值就会拆箱，提升为double，再装箱为Double。

25. 装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。

26. 可以在枚举类型中添加一些构造器、方法和域。当然，构造器只是在构造枚举常量的时候调用。

27. 所有枚举类型都是Enum类的子类。

28. 每个枚举类型都有一个静态的values方法，它将返回一个包含全部枚举值的数组。